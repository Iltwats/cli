From b1948b43c52f6b2748a2316b45972eda890c2336 Mon Sep 17 00:00:00 2001
From: Ajinkya <11447401+ajinkya599@users.noreply.github.com>
Date: Mon, 13 Dec 2021 15:52:52 +0530
Subject: [PATCH] Adding stacks consumption support

---
 pkg/cmd/repo/create/create.go | 143 ++++++++++++++++++++++++++++++++++
 pkg/cmd/repo/create/http.go   | 101 ++++++++++++++++++++++++
 2 files changed, 244 insertions(+)

diff --git a/pkg/cmd/repo/create/create.go b/pkg/cmd/repo/create/create.go
index dc1e0bf8fa..d73b8b2925 100644
--- a/pkg/cmd/repo/create/create.go
+++ b/pkg/cmd/repo/create/create.go
@@ -11,6 +11,7 @@ import (
 	"github.com/cli/cli/v2/api"
 	"github.com/cli/cli/v2/git"
 	"github.com/cli/cli/v2/internal/config"
+	"github.com/cli/cli/v2/internal/ghinstance"
 	"github.com/cli/cli/v2/internal/ghrepo"
 	"github.com/cli/cli/v2/internal/run"
 	"github.com/cli/cli/v2/pkg/cmdutil"
@@ -23,12 +24,14 @@ type CreateOptions struct {
 	HttpClient func() (*http.Client, error)
 	Config     func() (config.Config, error)
 	IO         *iostreams.IOStreams
+	Browser    cmdutil.Browser
 
 	Name              string
 	Description       string
 	Homepage          string
 	Team              string
 	Template          string
+	Stack             string
 	EnableIssues      bool
 	EnableWiki        bool
 	Public            bool
@@ -44,6 +47,7 @@ func NewCmdCreate(f *cmdutil.Factory, runF func(*CreateOptions) error) *cobra.Co
 		IO:         f.IOStreams,
 		HttpClient: f.HttpClient,
 		Config:     f.Config,
+		Browser:    f.Browser,
 	}
 
 	cmd := &cobra.Command{
@@ -125,6 +129,7 @@ func NewCmdCreate(f *cmdutil.Factory, runF func(*CreateOptions) error) *cobra.Co
 	cmd.Flags().StringVarP(&opts.Homepage, "homepage", "h", "", "Repository home page `URL`")
 	cmd.Flags().StringVarP(&opts.Team, "team", "t", "", "The `name` of the organization team to be granted access")
 	cmd.Flags().StringVarP(&opts.Template, "template", "p", "", "Make the new repository based on a template `repository`")
+	cmd.Flags().StringVarP(&opts.Stack, "stack", "s", "", "Make the new repository based on a stack `repository`")
 	cmd.Flags().BoolVar(&opts.EnableIssues, "enable-issues", true, "Enable issues in the new repository")
 	cmd.Flags().BoolVar(&opts.EnableWiki, "enable-wiki", true, "Enable wiki in the new repository")
 	cmd.Flags().BoolVar(&opts.Public, "public", false, "Make the new repository public")
@@ -349,6 +354,73 @@ func createRun(opts *CreateOptions) error {
 		templateRepoMainBranch = repo.DefaultBranchRef.Name
 	}
 
+	stdout := opts.IO.Out
+	if opts.Stack != "" {
+		var stackRepo ghrepo.Interface
+		apiClient := api.NewClientFromHTTP(httpClient)
+
+		stackRepoName := opts.Stack
+		if !strings.Contains(stackRepoName, "/") {
+			host, err := cfg.DefaultHost()
+			if err != nil {
+				return err
+			}
+			currentUser, err := api.CurrentLoginName(apiClient, host)
+			if err != nil {
+				return err
+			}
+			stackRepoName = currentUser + "/" + stackRepoName
+		}
+		stackRepo, err = ghrepo.FromFullName(stackRepoName)
+		if err != nil {
+			return fmt.Errorf("argument error: %w", err)
+		}
+
+		repo, err := api.GitHubRepo(apiClient, stackRepo)
+		if err != nil {
+			return err
+		}
+
+		// fmt.Fprintf(stdout, "Obtaining releases...\n")
+		releases, err := listReleases(opts, httpClient, stackRepo, repo.RepoHost())
+		if err != nil {
+			return err
+		}
+
+		// fmt.Fprintf(stdout, "seeking release...\n")
+		releaseTag, err := interactiveStackReleaseTag(releases)
+		if err != nil {
+			return err
+		}
+
+		stackData, err := getStackData(opts, httpClient, releaseTag, stackRepo, repo.RepoHost())
+		if err != nil {
+			return err
+		}
+
+		var stackInputs map[string]interface{}
+		stackInputs, err = interactiveStackInputs(stackData)
+		if err != nil {
+			return err
+		}
+
+		params := createRepositoryFromStackInput{
+			Name:       repoToCreate.RepoName(),
+			OwnerLogin: repoToCreate.RepoOwner(),
+			ReleaseTag: releaseTag,
+			Inputs:     stackInputs,
+			Private:    opts.Private,
+		}
+
+		fmt.Fprintf(stdout, "Creating repo from stack...\n")
+		createRepoFromStack(opts, httpClient, repo, repo.RepoHost(), params)
+		fmt.Fprintf(stdout, "Done!\n")
+
+		stackInProgressUrl := fmt.Sprintf("%s%s/%s", ghinstance.HostPrefix(repo.RepoHost()), repoToCreate.RepoOwner(), repoToCreate.RepoName())
+		fmt.Fprintf(stdout, "Browse here: %s\n", stackInProgressUrl)
+		return opts.Browser.Browse(stackInProgressUrl)
+	}
+
 	createLocalDirectory := opts.ConfirmSubmit
 	if !opts.ConfirmSubmit {
 		opts.ConfirmSubmit, err = confirmSubmission(input.Name, input.OwnerLogin, inLocalRepo)
@@ -576,6 +648,77 @@ func localInit(io *iostreams.IOStreams, remoteURL, path, checkoutBranch string)
 	return run.PrepareCmd(gitCheckout).Run()
 }
 
+func interactiveStackReleaseTag(releases []string) (string, error) {
+	qs := []*survey.Question{}
+
+	getReleaseTagQuestion := &survey.Question{
+		Name: "releaseTag",
+		Prompt: &survey.Select{
+			Message: "Release tag: ",
+			Options: releases,
+			Default: releases[0],
+		},
+	}
+
+	qs = append(qs, getReleaseTagQuestion)
+
+	answer := struct {
+		ReleaseTag string
+	}{}
+
+	err := prompt.SurveyAsk(qs, &answer)
+	if err != nil {
+		return "", err
+	}
+
+	return answer.ReleaseTag, nil
+}
+
+func interactiveStackInputs(sd stackData) (map[string]interface{}, error) {
+	qs := []*survey.Question{}
+
+	for _, input := range sd.Inputs {
+		var inputQuestion *survey.Question
+		isSecret := false
+		if input["is-secret"] != nil {
+			isSecret = input["is-secret"].(bool)
+		}
+
+		if isSecret {
+			inputQuestion = &survey.Question{
+				Name: input["name"].(string),
+				Prompt: &survey.Password{
+					Message: fmt.Sprintf("%s (%s)", input["name"], input["description"]),
+				},
+			}
+		} else {
+			defaultValue := ""
+			if input["default"] != nil {
+				defaultValue = input["default"].(string)
+			}
+
+			inputQuestion = &survey.Question{
+				Name: input["name"].(string),
+				Prompt: &survey.Input{
+					Message: fmt.Sprintf("%s (%s)", input["name"], input["description"]),
+					Default: defaultValue,
+				},
+			}
+		}
+
+		qs = append(qs, inputQuestion)
+	}
+
+	answers := map[string]interface{}{}
+	err := prompt.SurveyAsk(qs, &answers)
+
+	if err != nil {
+		return nil, err
+	}
+
+	return answers, nil
+}
+
 func interactiveRepoCreate(isDescEmpty bool, isVisibilityPassed bool, repoName string) (string, string, string, error) {
 	qs := []*survey.Question{}
 
diff --git a/pkg/cmd/repo/create/http.go b/pkg/cmd/repo/create/http.go
index 1cc6a47a63..4aff3b2aab 100644
--- a/pkg/cmd/repo/create/http.go
+++ b/pkg/cmd/repo/create/http.go
@@ -4,10 +4,13 @@ import (
 	"bytes"
 	"encoding/json"
 	"fmt"
+	"io"
 	"net/http"
 	"strings"
 
 	"github.com/cli/cli/v2/api"
+	"github.com/cli/cli/v2/internal/ghinstance"
+	"github.com/cli/cli/v2/internal/ghrepo"
 )
 
 // repoCreateInput is input parameters for the repoCreate method
@@ -60,6 +63,22 @@ type cloneTemplateRepositoryInput struct {
 	RepositoryID string `json:"repositoryId"`
 }
 
+type createRepositoryFromStackInput struct {
+	Name                string                 `json:"name"`
+	Private             bool                   `json:"private"`
+	Description         string                 `json:"description,omitempty"`
+	OwnerLogin          string                 `json:"ownerLogin"`
+	StackOwnerLogin     string                 `json:"stackOwnerLogin"`
+	StackRepositoryName string                 `json:"stackRepositoryName"`
+	ReleaseTag          string                 `json:"releaseTag"`
+	Inputs              map[string]interface{} `json:"inputs"`
+}
+
+type stackData struct {
+	Inputs []map[string]interface{}
+	Apps   []map[string]interface{}
+}
+
 // repoCreate creates a new GitHub repository
 func repoCreate(client *http.Client, hostname string, input repoCreateInput) (*api.Repository, error) {
 	isOrg := false
@@ -201,6 +220,88 @@ func repoCreate(client *http.Client, hostname string, input repoCreateInput) (*a
 	return api.InitRepoHostname(&response.CreateRepository.Repository, hostname), nil
 }
 
+func listReleases(opts *CreateOptions, httpClient *http.Client, baseRepo ghrepo.Interface, hostname string) ([]string, error) {
+	url := fmt.Sprintf("%srepos/%s/%s/releases", ghinstance.RESTPrefix(hostname), baseRepo.RepoOwner(), baseRepo.RepoName())
+	// stdout := opts.IO.Out
+	// fmt.Fprintf(stdout, "GET releases call url: %s\n", url)
+	req, err := http.NewRequest("GET", url, nil)
+	if err != nil {
+		return nil, err
+	}
+
+	resp, err := httpClient.Do(req)
+	if err != nil {
+		return nil, err
+	}
+
+	defer resp.Body.Close()
+	var releasesResponse []map[string]interface{}
+	json.NewDecoder(resp.Body).Decode(&releasesResponse)
+	releases := []string{}
+	for _, release := range releasesResponse {
+		// fmt.Fprintf(stdout, "Release tag: %s\n", release["tag_name"].(string))
+		releases = append(releases, release["tag_name"].(string))
+	}
+
+	return releases, nil
+}
+
+func getStackData(opts *CreateOptions, httpClient *http.Client, releaseTag string, baseRepo ghrepo.Interface, hostname string) (stackData, error) {
+	url := fmt.Sprintf("%srepos/%s/%s/stacks/data?release_tag=%s", ghinstance.RESTPrefix(hostname), baseRepo.RepoOwner(), baseRepo.RepoName(), releaseTag)
+	// stdout := opts.IO.Out
+	// fmt.Fprintf(stdout, "GET call url: %s\n", url)
+	var data stackData
+
+	req, err := http.NewRequest("GET", url, nil)
+	if err != nil {
+		return data, err
+	}
+
+	resp, err := httpClient.Do(req)
+	if err != nil {
+		return data, err
+	}
+
+	// var stackMetadata map[string][]map[string]string
+	var stackMetadata map[string][]map[string]interface{}
+	defer resp.Body.Close()
+	json.NewDecoder(resp.Body).Decode(&stackMetadata)
+	// fmt.Println("---\n---\n", stackMetadata)
+	data.Inputs = stackMetadata["inputs"]
+	data.Apps = stackMetadata["apps"]
+
+	return data, nil
+}
+
+func createRepoFromStack(opts *CreateOptions, httpClient *http.Client, baseRepo ghrepo.Interface, hostname string, input createRepositoryFromStackInput) (io.ReadCloser, error) {
+	url := fmt.Sprintf("%srepos/%s/%s/stacks", ghinstance.RESTPrefix(hostname), baseRepo.RepoOwner(), baseRepo.RepoName())
+	// stdout := opts.IO.Out
+	// fmt.Fprintf(stdout, "POST call url: %s\n", url)
+	payload := map[string]interface{}{
+		"owner":       input.OwnerLogin,
+		"name":        input.Name,
+		"release_tag": input.ReleaseTag,
+		"inputs":      input.Inputs,
+	}
+
+	payloadBytes, err := json.Marshal(payload)
+	if err != nil {
+		return nil, err
+	}
+
+	req, err := http.NewRequest("POST", url, bytes.NewBuffer(payloadBytes))
+	if err != nil {
+		return nil, err
+	}
+
+	resp, err := httpClient.Do(req)
+	if err != nil {
+		return nil, err
+	}
+
+	return resp.Body, nil
+}
+
 type ownerResponse struct {
 	NodeID string `json:"node_id"`
 	Type   string `json:"type"`
